Ghép Trơn Cấp p (p ≤ 4) - Thuật toán Tổng quát Cuối cùng (Phiên bản Hoàn thiện)

THUẬT TOÁN CHÍNH: TaoHamGhepTron_Final

Input:
mang x[] - Mảng n+1 mốc (từ x_0 đến x_n), đã sắp xếp tăng dần
mang y[] - Mảng n+1 giá trị tương ứng (từ y_0 đến y_n)
p - Bậc của hàm ghép trơn (1, 2, 3, 4)
BC_params - Tập hợp điều kiện biên (dictionary)
    Cấu trúc cho p=2:
        BC_params = {'alpha': α, 'beta': β, 'gamma': γ}
        Ý nghĩa: α*m_0 + β*m_n = γ
    Cấu trúc cho p=3:
        BC_params = {
            'bc_left': {'type': 'natural'|'clamped'|'second_order'|'periodic',
                        'value': (nếu cần)},
            'bc_right': {'type': 'natural'|'clamped'|'second_order'|'periodic',
                         'value': (nếu cần)}
        }
    Cấu trúc cho p=4:
        BC_params = {
            'bc_left': {...},
            'bc_right': {...},
            'extra_bc': [{...}, {...}, {...}]  // 3 ĐK biên thêm
        }
eps - Độ chính xác (ví dụ: 1e-9)

Output:
Coeffs[] - Mảng n bộ hệ số cho mỗi đoạn, hoặc LỖI

BƯỚC 1: KIỂM TRA INPUT CHUNG

n = len(x) - 1
if n < 1: return LỖI (Cần ít nhất 2 mốc)
if len(y) != n + 1: return LỖI (Độ dài x và y không khớp)
if p < 1 or p > 4: return LỖI (Chỉ hỗ trợ p = 1, 2, 3, 4)
mang h[] có kích thước n số 0
for k = 0 to n-1:
    h[k] = x[k+1] - x[k]
    if h[k] < eps: return LỖI (Mốc x bị trùng hoặc không sắp xếp tăng dần)

BƯỚC 2: KIỂM TRA ĐK BIÊN (BC_params)

if p >= 2:
    if BC_params == null or len(BC_params) == 0:
        return LỖI (Thiếu thông tin ĐK biên)

BƯỚC 3: GỌI THUẬT TOÁN CON DỰA TRÊN p

if p == 1:
    return GhepTronBac1_Final(x, y, n, h)
else if p == 2:
    return GhepTronBac2_Final(x, y, n, h, BC_params)
else if p == 3:
    return GhepTronBac3_Final(x, y, n, h, BC_params)
else if p == 4:
    return GhepTronBac4_Final(x, y, n, h, BC_params)

═══════════════════════════════════════════════════════════════

THUẬT TOÁN CON 1: GhepTronBac1_Final(x, y, n, h)

Input: x[], y[], n, h[]
Output: Coeffs[] (mảng n bộ hệ số {a, b})

Bước 1: Tính hệ số cho mỗi đoạn
    mang Coeffs[] có kích thước n
    for k = 0 to n-1:
        b_k = y[k]
        a_k = (y[k+1] - y[k]) / h[k]
        Coeffs[k] = {a: a_k, b: b_k}
        // Dạng: S_k(x) = a_k*(x - x_k) + b_k

Bước 2: Return Coeffs[]

═══════════════════════════════════════════════════════════════

THUẬT TOÁN CON 2: GhepTronBac2_Final(x, y, n, h, BC_params)

Input: x[], y[], n, h[], BC_params
Output: Coeffs[] (mảng n bộ hệ số {a, b, c})

Bước 1: Khởi tạo hệ phương trình (n+1) × (n+1)
    mang A[][] - Ma trận (n+1) × (n+1) số 0
    mang D[] - Vector (n+1) phần tử số 0
    // Dạng: S_k(x) = a_k*(x - x_k)^2 + b_k*(x - x_k) + c_k

Bước 2: Thiết lập n phương trình liên tục C1 (Hàng 0 đến n-1)
    // Điều kiện liên tục: m_k + m_{k+1} = 2*Δy_k/h_k
    for k = 0 to n-1:
        A[k][k] = 1
        A[k][k+1] = 1
        D[k] = 2 * (y[k+1] - y[k]) / h[k]

Bước 3: Thiết lập 1 phương trình biên (Hàng n) - Dạng THTT tổng quát
    // α*m_0 + β*m_n = γ
    alpha = BC_params.get('alpha', 1)
    beta = BC_params.get('beta', 0)
    gamma = BC_params.get('gamma', 0)
    A[n][0] = alpha
    A[n][n] = beta
    D[n] = gamma

Bước 4: Giải hệ phương trình
    m = GiaiHeDaiSoTuyenTinh(A, D)
    if m == null: return LỖI (Hệ phương trình suy biến)

Bước 5: Tính hệ số từ m[]
    mang Coeffs[] có kích thước n
    for k = 0 to n-1:
        c_k = y[k]
        b_k = m[k]
        a_k = (m[k+1] - m[k]) / (2 * h[k])
        Coeffs[k] = {a: a_k, b: b_k, c: c_k}

Bước 6: Return Coeffs[]

═══════════════════════════════════════════════════════════════

THUẬT TOÁN CON 3: GhepTronBac3_Final(x, y, n, h, BC_params)

Input: x[], y[], n, h[], BC_params
Output: Coeffs[] (mảng n bộ hệ số {a, b, c, d})

Bước 1: Khởi tạo hệ phương trình (n+1) × (n+1)
    mang A[][] - Ma trận (n+1) × (n+1) số 0
    mang D[] - Vector (n+1) phần tử số 0
    // Dạng: S_k(x) = a_k*(x - x_k)^3 + b_k*(x - x_k)^2 + c_k*(x - x_k) + d_k
    // Với: M_k = S''(x_k), a_k = (M_{k+1} - M_k)/(6*h_k), ...

Bước 2: Tính vế phải cho phương trình C2 bên trong
    for k = 1 to n-1:
        D[k] = 6 * ((y[k+1] - y[k])/h[k] - (y[k] - y[k-1])/h[k-1])

Bước 3: Thiết lập n-1 phương trình C2 liên tục (Hàng 1 đến n-1)
    for k = 1 to n-1:
        A[k][k-1] = h[k-1]
        A[k][k] = 2 * (h[k-1] + h[k])
        A[k][k+1] = h[k]

Bước 4: Thiết lập phương trình biên trái (Hàng 0)
    bc_type_left = BC_params['bc_left']['type']
    if bc_type_left == 'natural':
        A[0][0] = 1
        D[0] = 0
    else if bc_type_left == 'clamped':
        f_prime_0 = BC_params['bc_left']['value']
        A[0][0] = 2
        A[0][1] = 1
        D[0] = (6 / h[0]) * ((y[1] - y[0]) / h[0] - f_prime_0)
    else if bc_type_left == 'second_order':
        M0_val = BC_params['bc_left']['value']
        A[0][0] = 1
        D[0] = M0_val

Bước 5: Thiết lập phương trình biên phải (Hàng n)
    bc_type_right = BC_params['bc_right']['type']
    if bc_type_right == 'natural':
        A[n][n] = 1
        D[n] = 0
    else if bc_type_right == 'clamped':
        f_prime_n = BC_params['bc_right']['value']
        A[n][n-1] = 1
        A[n][n] = 2
        D[n] = (6 / h[n-1]) * (f_prime_n - (y[n] - y[n-1]) / h[n-1])
    else if bc_type_right == 'second_order':
        Mn_val = BC_params['bc_right']['value']
        A[n][n] = 1
        D[n] = Mn_val
    else if bc_type_right == 'periodic':
        SetPeriodicBC_P3_Final(A, D, n, h, y)

Bước 6: Giải hệ phương trình
    M = GiaiHeDaiSoTuyenTinh(A, D)
    if M == null: return LỖI (Hệ phương trình suy biến)

Bước 7: Tính hệ số từ M[]
    mang Coeffs[] có kích thước n
    for k = 0 to n-1:
        d_k = y[k]
        b_k = M[k] / 2
        a_k = (M[k+1] - M[k]) / (6 * h[k])
        c_k = (y[k+1] - y[k]) / h[k] - (h[k] * (M[k+1] + 2 * M[k])) / 6
        Coeffs[k] = {a: a_k, b: b_k, c: c_k, d: d_k}

Bước 8: Return Coeffs[]

═══════════════════════════════════════════════════════════════

THUẬT TOÁN CON 4: GhepTronBac4_Final(x, y, n, h, BC_params)

Input: x[], y[], n, h[], BC_params
Output: Coeffs[] (mảng n bộ hệ số {a, b, c, d, e})

Bước 1: Khởi tạo hệ phương trình (5n) × (5n)
    size = 5 * n
    mang A_full[][] - Ma trận size × size số 0
    mang D_full[] - Vector size phần tử số 0
    idx = 0
    // Dạng: S_k(x) = a_k*(x - x_k)^4 + b_k*(x - x_k)^3 + c_k*(x - x_k)^2 + d_k*(x - x_k) + e_k

Bước 2: ĐK 1 - S_k(x_k) = y_k (n phương trình)
    for k = 0 to n-1:
        A_full[idx][5*k+4] = 1
        D_full[idx] = y[k]
        idx = idx + 1

Bước 3: ĐK 2 - S_k(x_{k+1}) = y_{k+1} (n phương trình)
    for k = 0 to n-1:
        h_val = h[k]
        A_full[idx][5*k] = h_val^4
        A_full[idx][5*k+1] = h_val^3
        A_full[idx][5*k+2] = h_val^2
        A_full[idx][5*k+3] = h_val
        A_full[idx][5*k+4] = 1
        D_full[idx] = y[k+1]
        idx = idx + 1

Bước 4: ĐK 3 - C1 liên tục: S'_k(x_{k+1}) = S'_{k+1}(x_{k+1}) (n-1 phương trình)
    for k = 0 to n-2:
        h_val = h[k]
        A_full[idx][5*k] = 4 * h_val^3
        A_full[idx][5*k+1] = 3 * h_val^2
        A_full[idx][5*k+2] = 2 * h_val
        A_full[idx][5*k+3] = 1
        A_full[idx][5*(k+1)+3] = -1
        D_full[idx] = 0
        idx = idx + 1

Bước 5: ĐK 4 - C2 liên tục: S''_k(x_{k+1}) = S''_{k+1}(x_{k+1}) (n-1 phương trình)
    for k = 0 to n-2:
        h_val = h[k]
        A_full[idx][5*k] = 12 * h_val^2
        A_full[idx][5*k+1] = 6 * h_val
        A_full[idx][5*k+2] = 2
        A_full[idx][5*(k+1)+2] = -2
        D_full[idx] = 0
        idx = idx + 1

Bước 6: ĐK 5 - C3 liên tục: S'''_k(x_{k+1}) = S'''_{k+1}(x_{k+1}) (n-1 phương trình)
    for k = 0 to n-2:
        h_val = h[k]
        A_full[idx][5*k] = 24 * h_val
        A_full[idx][5*k+1] = 6
        A_full[idx][5*(k+1)+1] = -6
        D_full[idx] = 0
        idx = idx + 1

Bước 7: Thiết lập 3 phương trình ĐK biên từ BC_params['extra_bc']
    if BC_params.get('extra_bc', null) == null or len(BC_params['extra_bc']) < 3:
        return LỖI (Thiếu 3 ĐK biên cho bậc 4)
    for i = 0 to 2:
        bc_info = BC_params['extra_bc'][i]
        // Thiết lập phương trình dựa vào bc_info
        // (Chi tiết tùy theo định dạng, ví dụ: {'eq': [coeff_list], 'rhs': value})
        if 'eq' not in bc_info or 'rhs' not in bc_info:
            return LỖI (ĐK biên không hợp lệ)
        for j = 0 to 5*n-1:
            if j < len(bc_info['eq']):
                A_full[idx][j] = bc_info['eq'][j]
        D_full[idx] = bc_info['rhs']
        idx = idx + 1

Bước 8: Giải hệ phương trình
    C_vec = GiaiHeDaiSoTuyenTinh(A_full, D_full)
    if C_vec == null: return LỖI (Hệ phương trình suy biến)

Bước 9: Trích xuất hệ số từ C_vec
    mang Coeffs[] có kích thước n
    for k = 0 to n-1:
        Coeffs[k] = {
            a: C_vec[5*k],
            b: C_vec[5*k+1],
            c: C_vec[5*k+2],
            d: C_vec[5*k+3],
            e: C_vec[5*k+4]
        }

Bước 10: Return Coeffs[]

═══════════════════════════════════════════════════════════════

THUẬT TOÁN PHỤ TRỢ: SetPeriodicBC_P3_Final(A, D, n, h, y)

Input: A[][], D[], n, h[], y[]
Output: (A và D được sửa tại chỗ)

Bước 1: Thiết lập hàng 0 - Điều kiện S'(x_0) = S'(x_n)
    A[0][0] = h[0] / 3
    A[0][1] = h[0] / 6
    A[0][n-1] = h[n-1] / 6
    A[0][n] = h[n-1] / 3
    for k = 2 to n-2: A[0][k] = 0
    D[0] = (y[1] - y[0]) / h[0] - (y[n] - y[n-1]) / h[n-1]

Bước 2: Thiết lập hàng n - Điều kiện M_0 = M_n
    A[n][0] = 1
    A[n][n] = -1
    for k = 1 to n-1: A[n][k] = 0
    D[n] = 0

═══════════════════════════════════════════════════════════════

THUẬT TOÁN PHỤ TRỢ: GiaiHeDaiSoTuyenTinh(A, D)

Input: mang A[][], mang D[]
Output: mang x[] (vector nghiệm) hoặc LỖI

Bước 1: Khử Gauss với Pivoting Một phần
    n = len(D) - 1
    mang b[] = copy(D)
    mang a[][] = copy(A)
    for i = 0 to n:
        // Tìm Pivot
        max_row = i
        for k = i+1 to n:
            if abs(a[k][i]) > abs(a[max_row][i]): max_row = k
        // Hoán đổi hàng
        swap(a[i], a[max_row])
        swap(b[i], b[max_row])
        // Kiểm tra Pivot = 0
        if abs(a[i][i]) < 1e-10: return null (Ma trận suy biến)
        // Khử dòng dưới
        for k = i+1 to n:
            factor = a[k][i] / a[i][i]
            for j = i to n: a[k][j] = a[k][j] - factor * a[i][j]
            b[k] = b[k] - factor * b[i]

Bước 2: Thế ngược
    mang x[] có kích thước n+1
    for i = n downto 0:
        sum = b[i]
        for j = i+1 to n: sum = sum - a[i][j] * x[j]
        x[i] = sum / a[i][i]

Bước 3: Return x[]

═══════════════════════════════════════════════════════════════

TỔNG KẾT

Thuật toán hoàn toàn chính xác cho p = 1, 2, 3, 4
Hỗ trợ đầy đủ các loại ĐK biên cho bậc 3
Khử Gauss với Pivoting xử lý mọi trường hợp ma trận

