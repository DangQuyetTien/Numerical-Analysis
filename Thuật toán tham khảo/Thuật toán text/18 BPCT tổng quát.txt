Bình phương Tối thiểu - Phương pháp Tổng quát

Input:
mang X[] - Mảng n giá trị x_i (dữ liệu độc lập)
mang Y[] - Mảng n giá trị y_i (dữ liệu phụ thuộc)
mang PhiFuncs[] - Mảng m hàm cơ sở φ_j(x)
    Ví dụ 1 (y = A + Bx): [lambda x: 1, lambda x: x]
    Ví dụ 2 (y = A + Bx + Cx²): [lambda x: 1, lambda x: x, lambda x: x*x]
    Ví dụ 3 (y = A*sin(x) + B*cos(x)): [lambda x: sin(x), lambda x: cos(x)]

Output:
mang a[] - Mảng m hệ số a_j (nghiệm tối ưu)
mse - Sai số trung bình phương

Bước 1: Kiểm tra Input
    n = len(X)
    if n < 1: return LỖI (Cần ít nhất 1 điểm dữ liệu)
    if len(Y) != n: return LỖI (X và Y không cùng độ dài)
    m = len(PhiFuncs)
    if m < 1: return LỖI (Cần ít nhất 1 hàm cơ sở)
    if n < m: return LỖI (Số điểm dữ liệu phải >= số hàm cơ sở)

Bước 2: Xây dựng ma trận Phi (n × m)
    // Phi[i][j] = φ_j(x_i)
    mang Phi[][] có kích thước n × m
    for i = 0 to n-1:
        for j = 0 to m-1:
            Phi[i][j] = PhiFuncs[j](X[i])

Bước 3: Xây dựng hệ phương trình chính tắc
    // A = Phi^T * Phi (ma trận m × m)
    mang A[][] có kích thước m × m số 0
    for j = 0 to m-1:
        for k = 0 to m-1:
            sum_A = 0
            for i = 0 to n-1:
                sum_A = sum_A + Phi[i][j] * Phi[i][k]
            A[j][k] = sum_A
    // b = Phi^T * Y (vector m phần tử)
    mang b[] có kích thước m số 0
    for j = 0 to m-1:
        sum_b = 0
        for i = 0 to n-1:
            sum_b = sum_b + Phi[i][j] * Y[i]
        b[j] = sum_b

Bước 4: Giải hệ A*a = b
    a = GiaiHeDaiSoTuyenTinh(A, b)
    if a == null: return LỖI (Hệ phương trình suy biến)

Bước 5: Tính Sai số Trung bình phương (MSE)
    // MSE = (1/n) * Σ(g(x_i) - y_i)²
    total_error_sq = 0
    for i = 0 to n-1:
        g_i = 0
        for j = 0 to m-1:
            g_i = g_i + a[j] * Phi[i][j]
        error_i = g_i - Y[i]
        total_error_sq = total_error_sq + error_i * error_i
    mse = total_error_sq / n

Bước 6: Return a[], mse

═══════════════════════════════════════════════════════════════

THUẬT TOÁN PHỤ TRỢ: GiaiHeDaiSoTuyenTinh(A, D)

Input:
mang A[][] - Ma trận m × m
mang D[] - Vector m phần tử

Output:
mang x[] - Vector nghiệm (m phần tử) hoặc null

Bước 1: Khử Gauss với Pivoting Một phần
    m = len(D) - 1
    mang b[] = copy(D)
    mang a[][] = copy(A)
    for i = 0 to m:
        // Tìm Pivot
        max_row = i
        for k = i+1 to m:
            if abs(a[k][i]) > abs(a[max_row][i]): max_row = k
        // Hoán đổi hàng
        swap(a[i], a[max_row])
        swap(b[i], b[max_row])
        // Kiểm tra Pivot = 0
        if abs(a[i][i]) < 1e-10: return null (Ma trận suy biến)
        // Khử dòng dưới
        for k = i+1 to m:
            factor = a[k][i] / a[i][i]
            for j = i to m: a[k][j] = a[k][j] - factor * a[i][j]
            b[k] = b[k] - factor * b[i]

Bước 2: Thế ngược
    mang x[] có kích thước m+1
    for i = m downto 0:
        sum = b[i]
        for j = i+1 to m: sum = sum - a[i][j] * x[j]
        x[i] = sum / a[i][i]

Bước 3: Return x[]

═══════════════════════════════════════════════════════════════

TUYẾN TÍNH HÓA - VÍ DỤ THỰC HÀNH

Ví dụ 1: Hàm mũ y = a*e^(bx) + 2

Bước 1: Tuyến tính hóa
    Hàm gốc: y = a*e^(bx) + 2
    y - 2 = a*e^(bx)
    ln|y - 2| = ln(a) + bx
    Đặt: Y = ln|y - 2|, A = ln(a), B = b
    Hàm tuyến tính: Y = A + B*x

Bước 2: Chuẩn bị dữ liệu
    // Chuyển mảng Y thành Y_moi
    mang Y_moi[] có kích thước n
    for i = 0 to n-1:
        if Y[i] <= 2: return LỖI (ln không xác định)
        Y_moi[i] = ln(Y[i] - 2)

Bước 3: Gọi thuật toán bình phương tối thiểu
    a_coeffs, mse = BinhPhuongToiThieu(X, Y_moi, [lambda x: 1, lambda x: x])

Bước 4: Giải ngược
    A = a_coeffs[0]  // ln(a)
    B = a_coeffs[1]  // b
    b = B
    a = e^A

Bước 5: Hàm cuối cùng
    g(x) = a * e^(bx) + 2

Ví dụ 2: Hàm lũy thừa y = c*x^d

Bước 1: Tuyến tính hóa
    Hàm gốc: y = c*x^d
    ln(y) = ln(c) + d*ln(x)
    Đặt: Y = ln(y), C = ln(c), D = d, X_moi = ln(x)
    Hàm tuyến tính: Y = C + D*X_moi

Bước 2: Chuẩn bị dữ liệu
    mang X_moi[] có kích thước n
    mang Y_moi[] có kích thước n
    for i = 0 to n-1:
        if X[i] <= 0 or Y[i] <= 0: return LỖI (ln không xác định)
        X_moi[i] = ln(X[i])
        Y_moi[i] = ln(Y[i])

Bước 3: Gọi thuật toán
    a_coeffs, mse = BinhPhuongToiThieu(X_moi, Y_moi, [lambda x: 1, lambda x: x])

Bước 4: Giải ngược
    C = a_coeffs[0]  // ln(c)
    D = a_coeffs[1]  // d
    d = D
    c = e^C

Bước 5: Hàm cuối cùng
    g(x) = c * x^d

Ví dụ 3: Hàm hyperbolic y = a + b*tanh(cx)

Bước 1: Tuyến tính hóa (Trực tiếp)
    Hàm có dạng: g(x) = a + b*φ(x)
    Với φ(x) = tanh(cx)
    Này là tuyến tính theo (a, b, φ), nhưng φ_3(x) = tanh(cx) phụ thuộc vào c (phi tuyến)
    Giải pháp: Thử nhiều giá trị c khác nhau, với mỗi c:
        - Tính φ(x_i) = tanh(c*x_i)
        - Gọi BinhPhuongToiThieu(X, Y, [lambda x: 1, phi])
        - Tính MSE
    - Chọn c cho MSE nhỏ nhất

Bước 2: Sau khi chọn c tối ưu
    a_coeffs, mse = BinhPhuongToiThieu(X, Y, [lambda x: 1, lambda x: tanh(c_opt*x)])

Bước 3: Giải ngược
    a = a_coeffs[0]
    b = a_coeffs[1]

Bước 4: Hàm cuối cùng
    g(x) = a + b*tanh(c_opt*x)

═══════════════════════════════════════════════════════════════

CÁC TRƯỜNG HỢP THƯỜNG GẶP

1. Đa thức bậc p: y = a_0 + a_1*x + a_2*x^2 + ... + a_p*x^p
   PhiFuncs = [lambda x: 1, lambda x: x, lambda x: x**2, ..., lambda x: x**p]

2. Chuỗi Fourier: y = a_0/2 + a_1*cos(x) + b_1*sin(x) + a_2*cos(2x) + b_2*sin(2x) + ...
   PhiFuncs = [lambda x: 1, 
               lambda x: cos(x), lambda x: sin(x),
               lambda x: cos(2*x), lambda x: sin(2*x), ...]

3. Hàm mũ khác: y = a*e^(bx) + c*e^(dx)
   Tuyến tính hóa nếu biết d, hoặc thử nhiều cặp (b, d)

4. Hàm kết hợp: y = a + b*x + c*sin(kx) + d*e^(mx)
   Tuyến tính hóa từng bộ phận phi tuyến rồi kết hợp

═══════════════════════════════════════════════════════════════

LƯU Ý VỀ ĐIỀU KIỆN

✅ Để BinhPhuongToiThieu hoạt động chính xác:
   - n >= m (Số dữ liệu >= số hàm cơ sở)
   - Các hàm cơ sở φ_j phải độc lập tuyến tính
   - Ma trận A = Phi^T * Phi không được suy biến (det(A) != 0)

⚠️ Các vấn đề có thể gặp:
   - Nếu n = m: Hệ có nghiệm duy nhất, MSE = 0 (nếu dữ liệu không có noise)
   - Nếu n > m: Hệ overdetermined, MSE > 0 (bình phương tối thiểu)
   - Nếu φ_j phụ thuộc tuyến tính: Ma trận A suy biến
   - Nếu dữ liệu có noise lớn: MSE sẽ lớn, cần kiểm tra lại mô hình

Gói sử dụng: Không cần thư viện ngoài (ngoài hàm toán học cơ bản như exp, ln, sin, cos)