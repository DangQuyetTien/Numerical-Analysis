Nội suy Bessel

Input:
mang x[] - Mảng chứa n giá trị mốc x_i (đã sắp xếp)
mang y[] - Mảng chứa n giá trị y_i tương ứng
eps - Số rất nhỏ (ví dụ: 1e-9) để kiểm tra mốc

Output:
mang a[] - Mảng hệ số (bậc n-1) của P(x) từ bậc cao đến bậc thấp, hoặc LỖI

Bước 1: Kiểm tra Input
    n = len(x)
    if n == 0: return []
    if n == 1: return y
    if len(y) != n: return LỖI (Độ dài x và y không khớp)
    for i = 0 to n-2:
        if abs(x[i+1] - x[i]) < eps: return LỖI (Dữ liệu có mốc trùng)
    h = x[1] - x[0]
    for i = 2 to n-1:
        h_new = x[i] - x[i-1]
        if abs(h_new - h) > eps: return LỖI (Các mốc không cách đều)
    i_0 = floor((n - 1) / 2)

Bước 2: Xây dựng đa thức P(u)
    a_u = XayDungBesselU(y, i_0, n)

Bước 3: Chuyển đổi P(u) → P(x)
    x0 = x[i_0]
    a_x = TheU(a_u, x0, h)

Bước 4: Return a_x[]

Thuật toán phụ trợ 1: XayDungBesselU(y, i_0, n)

Input:
mang y[] - Mảng n giá trị
i_0 - Chỉ số trung tâm
n - Số phần tử

Output:
mang a_u[] - Mảng hệ số của P(u) (bậc cao → thấp)

Bước 1: Khởi tạo
    D_le, D_chan_avg = SaiPhanTrungTam_Bessel(y, i_0)
    mang a_u[] có kích thước n số 0
    mang W_chan[] = [1]
    mang W_le[] = [1, 0]
    a_u[n-1] = D_chan_avg[0]
    if n < 2: return a_u
    a_u[n-2] = D_le[0]

Bước 2: Vòng lặp xây dựng
    for i = 1 to floor((n-1) / 2):
        c_sq = ((2*i - 1) * (2*i - 1)) / 4.0
        k = 2 * i
        W_chan = NhanDaThucU2TruMinusC2(W_chan, c_sq)
        C_k = D_chan_avg[i] / giai_thua(k)
        len_W = len(W_chan)
        for j = 0 to len_W - 1:
            a_u[n - len_W + j] = a_u[n - len_W + j] + C_k * W_chan[j]
        k = 2 * i + 1
        if k >= n: break
        W_le = NhanDaThucU2TruMinusC2(W_le, c_sq)
        C_k = D_le[i] / giai_thua(k)
        len_W = len(W_le)
        for j = 0 to len_W - 1:
            a_u[n - len_W + j] = a_u[n - len_W + j] + C_k * W_le[j]

Bước 3: Return a_u[]

Thuật toán phụ trợ 2: TheU(a_u, x0, h)

Input:
mang a_u[] - Hệ số P(u) (bậc cao → thấp)
x0 - Mốc gốc
h - Bước nhảy

Output:
mang P_x[] - Hệ số P(x) (bậc cao → thấp)

Bước 1: Khởi tạo
    alpha = 1.0 / h
    beta = -(x0 / h + 0.5)
    n = len(a_u)
    mang C[] có kích thước n
    for i = 0 to n-1:
        C[i] = a_u[n - 1 - i]

Bước 2: Áp dụng lược đồ Horner tổng quát
    P_x = [C[n-1]]
    for i = n-2 downto 0:
        W_temp = NhanDaThucTuyenTinh(P_x, alpha, beta)
        W_temp[len(W_temp) - 1] = W_temp[len(W_temp) - 1] + C[i]
        P_x = W_temp

Bước 3: Return P_x[]

Thuật toán phụ trợ 3: SaiPhanTrungTam_Bessel(y, i_0)

Input:
mang y[] - Mảng n giá trị
i_0 - Chỉ số trung tâm

Output:
mang D_le[], D_chan_avg[] - Mảng sai phân lẻ và trung bình chẵn

Bước 1: Xây dựng bảng sai phân
    n = len(y)
    bang[][] - Bảng 2D kích thước n x n
    for j = 0 to n-1: bang[j][0] = y[j]
    for k = 1 to n-1:
        for j = 0 to n - 1 - k:
            bang[j][k] = bang[j+1][k-1] - bang[j][k-1]

Bước 2: Trích xuất sai phân Bessel
    mang D_le[] = []
    mang D_chan_avg[] = []
    for k = 0 to n-1:
        if k % 2 == 1:
            i = (k - 1) / 2
            j_index = i_0 - i
            add bang[j_index][k] to D_le
        else:
            i = k / 2
            if k == 0:
                avg = (bang[i_0][0] + bang[i_0+1][0]) / 2
            else:
                j_index_1 = i_0 - i
                j_index_2 = i_0 - i + 1
                avg = (bang[j_index_1][k] + bang[j_index_2][k]) / 2
            add avg to D_chan_avg

Bước 3: Return D_le[], D_chan_avg[]

Thuật toán phụ trợ 4: NhanDaThucU2TruMinusC2(p, c_sq)

Input:
mang p[] - Hệ số P(u) (bậc m) từ bậc cao → thấp
c_sq - Hằng số c²

Output:
mang b[] - Hệ số P(u)·(u² - c_sq) (bậc m+2)

Bước 1: Khởi tạo
    m = len(p) - 1
    mang b[] có kích thước m+3 số 0

Bước 2: Thực hiện phép nhân
    for j = 0 to m: b[j] = p[j]
    for j = 0 to m: b[j+2] = b[j+2] - c_sq * p[j]

Bước 3: Return b[]

Thuật toán phụ trợ 5: NhanDaThucTuyenTinh(p, alpha, beta)

Input:
mang p[] - Hệ số P(x) (bậc m) từ bậc cao → thấp
alpha, beta - Hệ số phép biến đổi tuyến tính

Output:
mang b[] - Hệ số P(α·x + β) (bậc m+1)

Bước 1: Khởi tạo
    m = len(p) - 1
    mang b[] có kích thước m+2 số 0

Bước 2: Thực hiện phép nhân
    for j = 0 to m: b[j] = p[j] * alpha
    for j = 0 to m: b[j+1] = b[j+1] + p[j] * beta

Bước 3: Return b[]

Thuật toán phụ trợ 6: giai_thua(k)

Input:
k - Số cần tính giai thừa

Output:
f - Giá trị k!

Bước 1: Kiểm tra điều kiện cơ sở
    if k == 0: return 1

Bước 2: Tính giai thừa
    f = 1
    for i = 1 to k:
        f = f * i

Bước 3: Return f

Gói sử dụng: Không cần thư viện ngoài, sử dụng các phép toán và cấu trúc dữ liệu cơ bản (mảng 2 chiều, vòng lặp, hàm floor)