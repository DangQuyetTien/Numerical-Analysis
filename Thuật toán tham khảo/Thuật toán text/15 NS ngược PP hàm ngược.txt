Nội suy Ngược - Phương pháp hàm ngược

Input:
mang x_all[] - Mảng chứa n giá trị mốc x_i ban đầu
mang y_all[] - Mảng chứa n giá trị y_i ban đầu
y_bar - Giá trị y mà ta muốn tìm x tương ứng
eps - Số rất nhỏ (ví dụ: 1e-9) để kiểm tra

Output:
x_bar - Giá trị x được nội suy, hoặc LỖI

Bước 1: Kiểm tra Input và Chuẩn bị dữ liệu
    n = len(x_all)
    if n != len(y_all): return LỖI (Dữ liệu x và y không khớp)
    is_increasing = y_all[1] > y_all[0]
    for i = 1 to n-2:
        if (is_increasing and y_all[i+1] < y_all[i]) or (not is_increasing and y_all[i+1] > y_all[i]):
            return LỖI (Dữ liệu y không đơn điệu. Phương pháp hàm ngược không thể áp dụng)
    for i = 0 to n-2:
        if abs(y_all[i+1] - y_all[i]) < eps:
            return LỖI (Dữ liệu y có mốc trùng)

Bước 2: Đảo vai trò dữ liệu
    y_mocs = y_all
    x_values = x_all

Bước 3: Tìm đa thức nội suy P(y)
    a = nsNewtonMocBatKy(y_mocs, x_values)

Bước 4: Tính giá trị x̄ tại y_bar
    x_bar = Tinh(a, y_bar)

Bước 5: Return x_bar

Thuật toán phụ trợ 1: nsNewtonMocBatKy(x_in, y_in)

Input:
mang x_in[] - Mảng mốc (trong trường hợp này là y_mocs)
mang y_in[] - Mảng giá trị (trong trường hợp này là x_values)

Output:
mang a[] - Mảng hệ số P(y) (bậc cao → thấp)

Bước 1: Khởi tạo
    n = len(x_in)
    mang a[] có kích thước n số 0
    mang W[] = [1]

Bước 2: Vòng lặp xây dựng
    for i = 0 to n-1:
        c = tsp(0, i, x_in, y_in)
        k = len(W)
        for j = 0 to k-1:
            a[n - k + j] = a[n - k + j] + c * W[j]
        if i < n-1:
            W = nhandathuc(W, x_in[i])

Bước 3: Return a[]

Thuật toán phụ trợ 1a: tsp(a, b, x, y)

Input:
a, b - Chỉ số bắt đầu và kết thúc
mang x[] - Mảng mốc
mang y[] - Mảng giá trị

Output:
kq - Giá trị tỷ sai phân f[x_a, ..., x_b]

Bước 1: Kiểm tra điều kiện cơ sở
    if a == b: return y[a]

Bước 2: Tính tỷ sai phân đệ quy
    return (tsp(a+1, b, x, y) - tsp(a, b-1, x, y)) / (x[b] - x[a])

Thuật toán phụ trợ 1b: nhandathuc(p, c)

Input:
mang p[] - Hệ số P(x) (bậc m) từ bậc cao → thấp
c - Hằng số

Output:
mang b[] - Hệ số Q(x) = P(x)·(x-c) (bậc m+1)

Bước 1: Khởi tạo
    m = len(p) - 1
    mang b[] có kích thước m+2 số 0

Bước 2: Tính hệ số
    b[0] = p[0]
    b[m+1] = -p[m] * c
    for j = 1 to m:
        b[j] = p[j] - p[j-1] * c

Bước 3: Return b[]

Thuật toán phụ trợ 2: Tinh(p, c)

Input:
mang p[] - Hệ số đa thức (bậc cao → thấp)
c - Giá trị cần tính (trong trường hợp này là y_bar)

Output:
kq - Giá trị P(c)

Bước 1: Khởi tạo
    n = len(p) - 1
    b = p[0]

Bước 2: Áp dụng lược đồ Horner
    for i = 1 to n:
        b = b * c + p[i]

Bước 3: Return b

Gói sử dụng: Không cần thư viện ngoài, sử dụng các phép toán và cấu trúc dữ liệu cơ bản (mảng 1 chiều, vòng lặp)