Nội suy Lagrange - Xây dựng đa thức nội suy

Input:
x[] - Mảng chứa n giá trị x_i (các mốc nội suy)
y[] - Mảng chứa n giá trị y_i tương ứng

Output:
a[] - Mảng hệ số (từ bậc cao đến thấp) của đa thức nội suy P(x)

Bước 1: Khởi tạo:
    n = len(x[])
    if n = 0: return [] 
	a[] chứa n số 0
	z[] chứa n - 1 số 0

Bước 2: Vòng lặp chính (tính tổng)
    for i = 0 to n-1:
        for j = 0 to n-1:
            if i != j: thêm x[j] vào z[]
        w[] = hoocneNhan(z[])
        c = Tinh(w[], x[i])
        if c == 0: return LỖI (Các điểm x_i không phân biệt)
        for j = 0 to n-1:
            a[j] = a[j] + (y[i] / c) * w[j]

Bước 3: Return a[]

Thuật toán phụ trợ 1: hoocneNhan(z[])

Bước 1: Khởi tạo
    k = len(z[])
    if k == 0: return [1]
    w = [1, -z[0]]

Bước 2: Lặp để nhân đa thức
    for i = 1 to k-1:
        w = nhandathuc(w, z[i])

Bước 3: Return w[]

Thuật toán phụ trợ 2: Tinh(p[], c)

Input:
mang p[] - Mảng hệ số của P(x) (bậc cao -> thấp)
c - Giá trị cần tính

Output:
b - Giá trị P(c)

Bước 1: Khởi tạo
    n = len(p) - 1
    if n < 0: return 0
    b = p[0]

Bước 2: Áp dụng lược đồ Horner
    for i = 1 to n:
        b = b * c + p[i]

Bước 3: Return b

Thuật toán phụ trợ 3: nhandathuc(p, c)

Input:
mang p[] - Mảng hệ số của P(x) (bậc m) từ cao đến thấp
c - Hằng số

Output:
mang b[] - Mảng hệ số của Q(x) = P(x)·(x-c) (bậc m+1)

Bước 1: Khởi tạo
    m = len(p) - 1
    mang b[] có kích thước m+2 số 0

Bước 2: Tính hệ số đầu tiên
    b[0] = p[0]

Bước 3: Tính hệ số cuối cùng
    b[m+1] = -p[m] * c

Bước 4: Lặp tính hệ số trung gian
    for j = 1 to m:
        b[j] = p[j] - p[j-1] * c

Bước 5: Return b[]

Gói sử dụng: Không cần thư viện ngoài, sử dụng các phép toán và cấu trúc dữ liệu cơ bản (mảng 1 chiều, vòng lặp)