Nội suy Newton Lùi - Mốc bất kỳ

Input:
x[] - Mảng chứa n giá trị mốc x_i
y[] - Mảng chứa n giá trị y_i tương ứng

Output:
a[] - Mảng hệ số (bậc n-1) của P(x) từ bậc cao đến bậc thấp

Bước 1: Khởi tạo
    n = len(x[])
    a[] có kích thước n số 0
    W[] = [1]

Bước 2: Vòng lặp xây dựng
    for i = 0 to n-1:
        c = tsp(n - 1 - i, n - 1, x, y)
        k = len(W)
        for j = 0 to k-1:
            a[n - k + j] = a[n - k + j] + c * W[j]
        if i < n-1:
            W[] = nhandathuc(W[], x[n - 1 - i])

Bước 3: Return a[]

Thuật toán phụ trợ 1: tsp(a, b, x, y)

Input:
a, b - Chỉ số bắt đầu và kết thúc
mang x[] - Mảng mốc
mang y[] - Mảng giá trị

Output:
kq - Giá trị tỷ sai phân f[x_a, ..., x_b]

Bước 1: Kiểm tra điều kiện cơ sở
    if a == b:
        return y[a]

Bước 2: Tính tỷ sai phân đệ quy
    return (tsp(a+1, b, x, y) - tsp(a, b-1, x, y)) / (x[b] - x[a])

Thuật toán phụ trợ 2: nhandathuc(p, c)

Input:
mang p[] - Mảng hệ số của P(x) (bậc m) từ bậc cao đến bậc thấp
c - Hằng số

Output:
mang b[] - Mảng hệ số của Q(x) = P(x)·(x-c) (bậc m+1)

Bước 1: Khởi tạo
    m = len(p[]) - 1
    b[] có chứa m+2 số 0

Bước 2: Tính hệ số đầu tiên
    b[0] = p[0]

Bước 3: Tính hệ số cuối cùng
    b[m+1] = -p[m] * c

Bước 4: Lặp tính hệ số trung gian
    for j = 1 to m:
        b[j] = p[j] - p[j-1] * c

Bước 5: Return b[]

Gói sử dụng: Không cần thư viện ngoài, sử dụng các phép toán và cấu trúc dữ liệu cơ bản (mảng 1 chiều, vòng lặp)
mochi search icon
