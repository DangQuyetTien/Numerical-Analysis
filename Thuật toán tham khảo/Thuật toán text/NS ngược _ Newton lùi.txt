Thuật toán Nội suy Newton Ngược P(y) - ĐTNS Lùi
Input: 
	Mảng y[] chứa các mốc dữ liệu
	Mảng x[] chứa giá trị tương ứng
Output: Mảng p[] chứa hệ số đa thức P(y) theo thứ tự [an, an-1, ..., a0]

Bước 1: Check điều kiện Input
Kiểm tra độ dài y[] và x[] có bằng nhau không, nếu không dừng
Kiểm tra y[] có cách đều không:
    h = y[1] - y[0]
    isEquidistant = True
    For i = 1 to len(y) - 1:
        If y[i] - y[i-1] ≠ h:
            isEquidistant = False
            break
Kiểm tra có phần tử trùng lặp trong y[] không, nếu có -> chọn xóa mốc trùng

Bước 2: Khởi tạo:
	n = len(y) - 1
	d[][] = mảng (n+1) x (n+1) số 0
	p[] = mảng n+1 số 0
	w[] = mảng 1 phần tử [1]

Bước 3: Xử lý dựa trên kết quả kiểm tra
Nếu isEquidistant = True thực hiện 3a, 3b
Nếu isEquidistant = False thực hiện 3c, 3d

Bước 3a: Lập bảng sai phân
For i = 0 to n:
    d[i][0] = x[i]
For j = 1 to n:
    For i = n downto j:
        d[i][j] = d[i][j-1] - d[i-1][j-1]

Bước 3b: Xây dựng đa thức Newton lùi
p[0] = d[n][0]
For i = 1 to n:
    c = d[n][i] / fact(i)
    w = nhan(w, [-(i-1), 1])
    For j = 0 to len(w) - 1:
        p[j] = p[j] + c * w[j]

Bước 3c: Lập bảng tỉ sai phân
For i = 0 to n:
    d[i][0] = x[i]
For j = 1 to n:
    For i = n downto j:
        d[i][j] = (d[i][j-1] - d[i-1][j-1]) / (y[i] - y[i-j])

Bước 3d: Xây dựng đa thức Newton lùi mốc bất kỳ
p[0] = d[n][0]
For i = 1 to n:
    c = d[n][i]
    w = nhan(w, [-y[n-i], 1])
    For j = 0 to len(w) - 1:
        p[j] = p[j] + c * w[j]

Bước 4: Đảo ngược mảng hệ số
daonguoc(p)

Bước 5: Return p

Hàm nhan(b[], c[])
Nhân hai đa thức b[] và c[]
	n1 = len(b)
	n2 = len(c)
	a[] = mảng (n1 + n2 - 1) số 0
	For i = 0 to n1 - 1:
		For j = 0 to n2 - 1:
			a[i + j] = a[i + j] + b[i] * c[j]
	Return a[]

Hàm daonguoc(a[])
Đảo ngược mảng
	n = len(a)
	For i = 0 to n/2 - 1:
		swap(a[i], a[n - 1 - i])

Hàm fact(k)
Tính giai thừa
	If k ≤ 1: return 1
	Else: return k * fact(k-1)