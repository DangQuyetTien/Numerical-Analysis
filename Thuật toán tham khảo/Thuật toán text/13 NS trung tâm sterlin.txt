Nội suy Stirling

Input:
mang x[] - Mảng chứa n giá trị mốc x_i (đã sắp xếp)
mang y[] - Mảng chứa n giá trị y_i tương ứng
eps - Số rất nhỏ (ví dụ: 1e-9) để kiểm tra mốc

Output:
mang a[] - Mảng hệ số (bậc n-1) của P(x) từ bậc cao đến bậc thấp, hoặc LỖI

Bước 1: Kiểm tra Input
    n = len(x)
    if n == 0: return []
    if n == 1: return y
    if len(y) != n: return LỖI (Độ dài x và y không khớp)
    for i = 0 to n-2:
        if abs(x[i+1] - x[i]) < eps: return LỖI (Dữ liệu có mốc trùng)
    h = x[1] - x[0]
    for i = 2 to n-1:
        h_new = x[i] - x[i-1]
        if abs(h_new - h) > eps: return LỖI (Các mốc không cách đều)
    i_0 = floor((n - 1) / 2)

Bước 2: Xây dựng đa thức P(t)
    a_t = XayDungStirlingT(y, i_0, n)

Bước 3: Chuyển đổi P(t) → P(x)
    a_x = ThePT(a_t, x[i_0], h)

Bước 4: Return a_x[]

Thuật toán phụ trợ 1: XayDungStirlingT(y, i_0, n)

Input:
mang y[] - Mảng n giá trị
i_0 - Chỉ số trung tâm
n - Số phần tử

Output:
mang a_t[] - Mảng hệ số của P(t) (bậc cao → thấp)

Bước 1: Khởi tạo
    D_chan, D_le = SaiPhanTrungTam_Stirling(y, i_0)
    mang a_t[] có kích thước n số 0
    mang W_chan[] = [1]
    mang W_le[] = [1, 0]
    a_t[n-1] = D_chan[0]
    i = 1
    k = 1

Bước 2: Vòng lặp xây dựng
    while k < n:
        f_k = giai_thua(k)
        C_k_le = D_le[i-1] / f_k
        len_W = len(W_le)
        for j = 0 to len_W - 1:
            a_t[n - len_W + j] = a_t[n - len_W + j] + C_k_le * W_le[j]
        k = k + 1
        if k >= n: break
        c_sq_chan = (i-1) * (i-1)
        W_chan = NhanDaThucT2TruMinusC2(W_chan, c_sq_chan)
        f_k = giai_thua(k)
        C_k_chan = D_chan[i] / f_k
        len_W = len(W_chan)
        for j = 0 to len_W - 1:
            a_t[n - len_W + j] = a_t[n - len_W + j] + C_k_chan * W_chan[j]
        c_sq_le = i * i
        W_le = NhanDaThucT2TruMinusC2(W_le, c_sq_le)
        i = i + 1
        k = k + 1

Bước 3: Return a_t[]

Thuật toán phụ trợ 2: ThePT(a_t, x0, h)

Input:
mang a_t[] - Hệ số P(t) (bậc cao → thấp)
x0 - Mốc gốc
h - Bước nhảy

Output:
mang P_x[] - Hệ số P(x) (bậc cao → thấp)

Bước 1: Chuyển đổi hệ số
    n = len(a_t)
    mang C[] có kích thước n
    for i = 0 to n-1:
        C[i] = a_t[n - 1 - i] / (h^i)

Bước 2: Áp dụng lược đồ Horner
    P_x = [C[n-1]]
    for i = n-2 downto 0:
        W_temp = nhandathuc(P_x, x0)
        W_temp[len(W_temp) - 1] = W_temp[len(W_temp) - 1] + C[i]
        P_x = W_temp

Bước 3: Return P_x[]

Thuật toán phụ trợ 3: SaiPhanTrungTam_Stirling(y, i_0)

Input:
mang y[] - Mảng n giá trị
i_0 - Chỉ số trung tâm

Output:
mang D_chan[], D_le[] - Mảng sai phân chẵn và lẻ

Bước 1: Xây dựng bảng sai phân
    n = len(y)
    bang[][] - Bảng 2D kích thước n x n
    for j = 0 to n-1: bang[j][0] = y[j]
    for k = 1 to n-1:
        for j = 0 to n - 1 - k:
            bang[j][k] = bang[j+1][k-1] - bang[j][k-1]

Bước 2: Trích xuất sai phân Stirling
    mang D_chan[] = []
    mang D_le[] = []
    for k = 0 to n-1:
        if k % 2 == 0:
            i = k / 2
            j_index = i_0 - i
            add bang[j_index][k] to D_chan
        else:
            i = (k - 1) / 2
            j_index_1 = i_0 - i
            j_index_2 = i_0 - i - 1
            avg = (bang[j_index_1][k] + bang[j_index_2][k]) / 2
            add avg to D_le

Bước 3: Return D_chan[], D_le[]

Thuật toán phụ trợ 4: NhanDaThucT2TruMinusC2(p, c_sq)

Input:
mang p[] - Hệ số P(t) (bậc m) từ bậc cao → thấp
c_sq - Hằng số c²

Output:
mang b[] - Hệ số P(t)·(t² - c_sq) (bậc m+2)

Bước 1: Khởi tạo
    m = len(p) - 1
    mang b[] có kích thước m+3 số 0

Bước 2: Thực hiện phép nhân
    for j = 0 to m: b[j] = p[j]
    for j = 0 to m: b[j+2] = b[j+2] - c_sq * p[j]

Bước 3: Return b[]

Thuật toán phụ trợ 5: nhandathuc(p, c)

Input:
mang p[] - Hệ số P(x) (bậc m) từ bậc cao → thấp
c - Hằng số

Output:
mang b[] - Hệ số Q(x) = P(x)·(x-c) (bậc m+1)

Bước 1: Khởi tạo
    m = len(p) - 1
    mang b[] có kích thước m+2 số 0

Bước 2: Tính hệ số
    b[0] = p[0]
    b[m+1] = -p[m] * c
    for j = 1 to m:
        b[j] = p[j] - p[j-1] * c

Bước 3: Return b[]

Thuật toán phụ trợ 6: giai_thua(k)

Input:
k - Số cần tính giai thừa

Output:
f - Giá trị k!

Bước 1: Kiểm tra điều kiện cơ sở
    if k == 0: return 1

Bước 2: Tính giai thừa
    f = 1
    for i = 1 to k:
        f = f * i

Bước 3: Return f

Gói sử dụng: Không cần thư viện ngoài, sử dụng các phép toán và cấu trúc dữ liệu cơ bản (mảng 2 chiều, vòng lặp, hàm floor)